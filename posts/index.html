<!DOCTYPE html>
<html lang="zh-Hans">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Summer&#39;s Blog</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.69.2" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
    
      <link href="/summer-xuepan.github.io/dist/css/app.4fc0b62e4b82c997bb0041217cd6b979.css" rel="stylesheet">
    

    

    
      

    

    
    
      <link href="/summer-xuepan.github.io/posts/index.xml" rel="alternate" type="application/rss+xml" title="Summer&#39;s Blog" />
      <link href="/summer-xuepan.github.io/posts/index.xml" rel="feed" type="application/rss+xml" title="Summer&#39;s Blog" />
      
    
    
    <meta property="og:title" content="Posts" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://xuepan-summer.github.io/summer-xuepan.github.io/posts/" />
<meta property="og:updated_time" content="2020-12-18T10:30:14+08:00" />
<meta itemprop="name" content="Posts">
<meta itemprop="description" content=""><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Posts"/>
<meta name="twitter:description" content=""/>

	
  </head>

  <body class="ma0 avenir bg-near-white">

    

  <header>
    <div class="pb3-m pb6-l bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/summer-xuepan.github.io/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        Summer&#39;s Blog
      
    </a>
    <div class="flex-l items-center">
      

      
      















    </div>
  </div>
</nav>

      <div class="tc-l pv3 ph3 ph4-ns">
        <h1 class="f2 f-subheadline-l fw2 light-silver mb0 lh-title">
          Posts
        </h1>
        
      </div>
    </div>
  </header>


    <main class="pb7" role="main">
      
  <article class="pa3 pa4-ns nested-copy-line-height nested-img">
    <section class="cf ph3 ph5-l pv3 pv4-l f4 tc-l center measure-wide lh-copy mid-gray"></section>
    <section class="flex-ns flex-wrap justify-around mt5">
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://xuepan-summer.github.io/summer-xuepan.github.io/posts/oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93/" class="link black dim">
        Oracle数据库函数总结
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      将平时SQL中遇到的oracle数据函数总结一下，便于遗忘时翻阅
1.lpad &amp; rpad
lpad(string,n,[pad&hellip;string]) 给定字符左侧添加指定字符至长度n. rpad(string,n,[pad..string]) 给定字符右侧添加指定字符至长度n.
2.substr
substr(string, int a, int b) 给定字符串从位置 a(a为0或1时表示从第一个字符开始截取)开始 截取b长度个字符 substr(string,int a) 从位置a开始，一直截取给定字符串到串尾
3.decode
decode(条件，值1，返回值1，值2，返回值2，..值 n，返回值n，缺省值)&rdquo; IF条件=值1 THEN RETURN 返回值1 ELSE IF条件=值2 THEN RETURN返回值2 &hellip; ELSE IF条件=值n then RETURN返回值n ELSE RETURN 缺省值
4.nvl
nvl(string1, replace_with) 如果string1为null，则返回replace_with，否则返回string1
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://xuepan-summer.github.io/summer-xuepan.github.io/posts/%E5%91%BD%E4%BB%A4%E6%9F%A5%E7%9C%8Boracle%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/" class="link black dim">
        命令查看oracle事务隔离级别
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      出于好奇，想看一下目前项目里oracle使用事务隔离级别是否是默认的，所以用命令验证了一下： 注：创建完之后先别commit，直接select即可选出数据
运行结果说明项目里目前没有修改oracle的事务隔离级别，仍然是默认的READ COMMITED读已提交
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://xuepan-summer.github.io/summer-xuepan.github.io/posts/%E6%B5%85%E8%B0%88%E4%BA%8B%E5%8A%A1/" class="link black dim">
        浅谈事务
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      浅谈事务(transaction)  事务的概念：  事务是DBMS（可靠数据库管理系统）中最基本的单位，通俗来讲就是要做的事情。包括四大特性（ACID）：Atomicity 原子性、Consistency 一致性、Isolation 隔离性、Durability持久性。
 事务四大特性：   原子性：事务是不可分割的整体，事务里的操作要么都实现要么都不实现，体现了原子性。  eg：甲给乙转钱，乙收钱，要么整个过程成功（甲扣钱，乙收钱），要么整个过程不成功（甲未扣钱，乙未收钱）。
 一致性：甲给乙转的钱和乙收到的钱是一致的。整个过程是维持平衡的。
  隔离性：事务之间是隔离的，即使不同事务处理相同的数据，也要有修改隔离。（即修改也是相互独立的）
  持久性：事务一旦提交，将持久保存在数据库中。
   事务高并发产生问题：    脏读(Dirty Read)：事务B读到了事务A已修改但未提交的数据。如果事务A提交失败，那么这B就读到了脏数据。
  不可重复读(Unrepeatable Read)：一个事务多次查询同一数据，结果不一致。因为受到了其他事务的干扰。
  幻读(Phantom Read)：例如事务A将1改成2，事务B插入了数据1，那么还是可以选出来值为1的数据
三者区别
① 脏读&amp;不可重复读：脏读是因为修改未提交，但不可重复读是因为有别的事务插手，读取了其他事务提交的数据，所以数据不一致
② 不可重复读&amp;幻读：不可重复读针对同一数据项，幻读针对一批数据整体（比如数据条数）
针对以上问题，隔离性就起了作用，如何使事务之间隔离起来，互不影响？因此产生了事务隔离级别。
   事务隔离级别：  ×表示不会出现，√表示可能会出现
   事务隔离级别 脏读 不可重复读 幻读     Read uncommitted √ √ √   Read committed × √ √   Repeatable read × × √   Serializable × × ×    ① Read uncommitted (读未提交)：最低的事务隔离级别，一个事务还没提交时，它做的变更就能被别的事务看到。
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://xuepan-summer.github.io/summer-xuepan.github.io/posts/comparable%E5%8F%8Acomparator%E5%AF%B9%E6%AF%94/" class="link black dim">
        Comparable及Comparator对比
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      comparable接口:
public interface Comparable { int compareTo(Object other); } public interface Comparable&lt;T&gt; { int compareTo(&lt;T&gt; other); } 实现该接口的类必须要覆写compareTo方法
comparator接口:
public interface Comparator&lt;T&gt;{ int compare(T first,T second) } 实现该接口的类必须要覆写compare方法
if (user1.getAge() &gt; user2.getAge()) { return 1; } if (user1.getAge() &lt; user2.getAge()) { return -1; } return 0; 代码可以简化为：
return Integer.compare(user1.getAge(), user2.getAge()); Collections.sort(userList, new Comparator&lt;User&gt;() { @Override public int compare(User user1, User user2) { return Integer.compare(user1.getAge(), user2.getAge()); } }); //声明一个匿名内部类，覆写了Comparator接口的compare方法，里面定义了比较的标准 可以简化为：
Collections.sort(userList, (user1, user2) -&gt; Integer.
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://xuepan-summer.github.io/summer-xuepan.github.io/posts/arraylist%E6%89%A9%E5%AE%B9/" class="link black dim">
        ArrayList扩容
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      总结： ArrayList的底层是Object数组，默认容量为10，当往ArrayList里添加数据的时候，才会进行扩容。扩容主要由grow方法实现，扩容为之前的1.5倍左右，然后将之前的数据放到新数组里。
private static final int DEFAULT_CAPACITY = 10; private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}; transient Object[] elementData; // non-private to simplify nested class access 一、3种构造方法：
1.无参构造
public ArrayList() { this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; } 默认是一个空Object数组
2.集合作为参数的构造方法
public ArrayList(Collection&lt;? extends E&gt; c) { elementData = c.toArray(); if ((size = elementData.length) != 0) { // c.toArray might (incorrectly) not return Object[] (see 6260652)  if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://xuepan-summer.github.io/summer-xuepan.github.io/posts/push%E5%A4%B1%E8%B4%A5/" class="link black dim">
        IDEA push失败 Unable to access &#39;https://github.com/XXX/&#39;: Operation timed out ...
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
       出错原因  应该是网速太慢，所以push超时。
 操作    （pull的命令行格式是：git pull ）
在终端Terminal里输入git pull origin master &ndash;allow-unrelated-histories**（注意前面是两个‘-’，后面是一个‘-’）**
  该命令表示从远程仓库的origin分支拉取到本地的master分支
&ndash;allow-unrelated-histories的意思是允许合并不相关的历史，所以会进行强行合并
之后再次push即可，可以使用VCS-&gt;Git-&gt;Push进行push  
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://xuepan-summer.github.io/summer-xuepan.github.io/posts/%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E4%B8%89/" class="link black dim">
        实现生产者消费者(三)：BlockingQueue
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      生产者-消费者模型介绍  生产者和消费者同一时间使用同一存储空间，生产者往空间里放东西，消费者从空间里拿东西
现在要实现的是：生产者生产十个随机数供消费者使用，消费者依次消耗十个随机数，相当于生产者生产一个随机数，就放在盘子里，然后消费者消费。生产者再生产，消费者再消费，直至十个随机数被消耗完，整个过程结束。
采用BlockingQueue方法  BlockingQueue是接口，顾名思义，就是阻塞队列，队列中有空位才插入元素，队列中有元素才移除元素。
offer() &amp; put()
boolean offer(E e);若可以成功添加，返回true，否则返回false &ndash;&gt;非阻塞
boolean offer(E e, long timeout, TimeUnit unit) throws InterruptedException;
设定等待时间，如果指定时间内，还不能往队列中加入元素，则返回false &ndash;&gt;阻塞
void put(E e) throws InterruptedException;是阻塞的，如果队列内无空位，则一直等待，直到有空位才往队列中插入元素 &ndash;&gt;阻塞
poll() &amp; take()
E poll(long timeout, TimeUnit unit) throws InterruptedException;取出队首元素，可取出就直接返回，否则等待，超时还未取出则失败
E take() throws InterruptedException;取出队首元素，阻塞等待直到可取出
JDK文档的注释中有相关使用范例代码，如下所示：
class BoundedBuffer { final Lock lock = new ReentrantLock(); final Condition notFull = lock.newCondition(); final Condition notEmpty = lock.newCondition(); final Object[] items = new Object[100]; int putptr, takeptr, count; public void put(Object x) throws InterruptedException { lock.
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://xuepan-summer.github.io/summer-xuepan.github.io/posts/%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E4%BA%8C/" class="link black dim">
        实现生产者消费者(二)：Lock &amp; Condition
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      生产者-消费者模型介绍  生产者和消费者同一时间使用同一存储空间，生产者往空间里放东西，消费者从空间里拿东西
现在要实现的是：生产者生产十个随机数供消费者使用，消费者依次消耗十个随机数，相当于生产者生产一个随机数，就放在盘子里，然后消费者消费。生产者再生产，消费者再消费，直至十个随机数被消耗完，整个过程结束。
采用Lock &amp; Condition方法  Lock是接口，里面有lock()方法和unlock()方法，除此之外，还有tryLock()方法、newCondition()方法等。相比于synchronized更加灵活，因为synchronized默认在出作用域的时候释放资源，相当于解锁。所以Lock可以更加灵活地控制何时上锁，何时解锁。
Condition也是接口，主要是await()方法和signal()/signalAll()方法。signal()方法会唤醒一个正在等待该Condition的线程，而signalAll()方法会唤醒所有正在等待该Condition的线程。
JDK文档的注释中有相关使用范例代码，如下所示：
class BoundedBuffer { final Lock lock = new ReentrantLock(); final Condition notFull = lock.newCondition(); final Condition notEmpty = lock.newCondition(); final Object[] items = new Object[100]; int putptr, takeptr, count; public void put(Object x) throws InterruptedException { lock.lock(); try { while (count == items.length) notFull.await(); items[putptr] = x; if (++putptr == items.length) putptr = 0; ++count; notEmpty.signal(); } finally { lock.
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://xuepan-summer.github.io/summer-xuepan.github.io/posts/%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E4%B8%80/" class="link black dim">
        实现生产者消费者(一)：wait() &amp; notify()
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      生产者-消费者模型介绍  生产者和消费者同一时间使用同一存储空间，生产者往空间里放东西，消费者从空间里拿东西
现在要实现的是：生产者生产十个随机数供消费者使用，消费者依次消耗十个随机数，相当于生产者生产一个随机数，就放在盘子里，然后消费者消费。生产者再生产，消费者再消费，直至十个随机数被消耗完，整个过程结束。
采用Object.wait() &amp; notify()/notifyAll()方法  wait()表示让该线程等待
notify()/notifyAll()
Wakes up a single thread that is waiting on this object's monitor. If any threads are waiting on this object, one of them is chosen to be awakened. The choice is arbitrary and occurs at the discretion of the implementation. A thread waits on an object's monitor by calling one of the {@code wait} methods. notify()会随机唤醒一个等待该资源的线程
Wakes up all threads that are waiting on this object's monitor.
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://xuepan-summer.github.io/summer-xuepan.github.io/posts/stream%E6%80%BB%E7%BB%93%E5%8F%8Acollections.sort%E6%96%B9%E6%B3%95%E5%BA%94%E7%94%A8/" class="link black dim">
        Stream总结 &amp; Collections.sort()应用
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      学习了Stream之后，打算把Stream如何使用总结一下，便于下次翻阅。
一、Stream的创建操作、中间操作和终结操作 创建操作产生Stream
①某collection.stream()
②某stream.of()
③某string.chars()
④IntStream.range() 左闭右开
中间操作仍返回Stream
①filter() 过滤
②map() 映射
eg:map(User::getName)【方法引用】
③sorted()
eg:sorted(Comparator.comparing(某字段).thenComparing(某字段))
终结操作返回非Stream，包括void
①forEach()
②count()/max()/min()
③findFirst()/findAny
④anyMatch()/noneMatch()
collect()※ 是最常用的
Collectors.toList/toSet/toCollection
eg:Collectors.toCollection(TreeSet::new)
Collectors.groupingBy() 分组
eg:Collectors.groupingBy(Employee::getDepartment)
Collectors.joining() 连接
eg:Collectors.joining(&quot;, &ldquo;)
Collectors.summingInt() 累加求和
eg:Collectors.summingInt(Employee::getSalary)
二、Collections.sort()应用 1.包含两种传参方法
Collections.sort(list)
Collections.sort(list,Comparator)
2.java8新特性结合Collections.sort()
根据User的name对users(User类型的List)进行排序
有以下三种方法：
1.Comparator可以写成匿名内部类，实现compare方法
//1. Collections.sort(users, new Comparator&lt;User&gt;() { @Override public int compare(User user1, User user2) { return user1.getName().compareTo(user2.getName()); } }); 2.Comparator可以写成lambda表达式，如果写return的话需要加分号！
2.1是加上了参数类型的，参数表的参数类型可以忽略，如2.2所示
//2.1 复杂 Collections.sort(users, (User user1, User user2) -&gt; { return user1.
    </div>
  </div>
</div>
</div>
      
    </section>

<ul class="pagination">
    
    <li class="page-item">
        <a href="/summer-xuepan.github.io/posts/" class="page-link" aria-label="First"><span aria-hidden="true">&laquo;&laquo;</span></a>
    </li>
    
    <li class="page-item disabled">
    <a  class="page-link" aria-label="Previous"><span aria-hidden="true">&laquo;</span></a>
    </li>
    
    
    
    
    
    
    
        
        
    
    
    <li class="page-item active"><a class="page-link" href="/summer-xuepan.github.io/posts/">1</a></li>
    
    
    
    
    
    
        
        
    
    
    <li class="page-item"><a class="page-link" href="/summer-xuepan.github.io/posts/page/2/">2</a></li>
    
    
    <li class="page-item">
    <a href="/summer-xuepan.github.io/posts/page/2/" class="page-link" aria-label="Next"><span aria-hidden="true">&raquo;</span></a>
    </li>
    
    <li class="page-item">
        <a href="/summer-xuepan.github.io/posts/page/2/" class="page-link" aria-label="Last"><span aria-hidden="true">&raquo;&raquo;</span></a>
    </li>
    
</ul>

</article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://xuepan-summer.github.io/summer-xuepan.github.io/" >
    &copy;  Summer's Blog 2020 
  </a>
    <div>














</div>
  </div>
</footer>

    

  <script src="/summer-xuepan.github.io/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
