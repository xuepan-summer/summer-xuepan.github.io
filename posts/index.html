<!DOCTYPE html>
<html lang="zh-Hans">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Summer&#39;s Blog</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.69.2" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
    
      <link href="/summer-xuepan.github.io/dist/css/app.4fc0b62e4b82c997bb0041217cd6b979.css" rel="stylesheet">
    

    

    
      

    

    
    
      <link href="/summer-xuepan.github.io/posts/index.xml" rel="alternate" type="application/rss+xml" title="Summer&#39;s Blog" />
      <link href="/summer-xuepan.github.io/posts/index.xml" rel="feed" type="application/rss+xml" title="Summer&#39;s Blog" />
      
    
    
    <meta property="og:title" content="Posts" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://xuepan-summer.github.io/summer-xuepan.github.io/posts/" />
<meta property="og:updated_time" content="2020-11-16T18:21:50+08:00" />
<meta itemprop="name" content="Posts">
<meta itemprop="description" content=""><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Posts"/>
<meta name="twitter:description" content=""/>

	
  </head>

  <body class="ma0 avenir bg-near-white">

    

  <header>
    <div class="pb3-m pb6-l bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/summer-xuepan.github.io/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        Summer&#39;s Blog
      
    </a>
    <div class="flex-l items-center">
      

      
      















    </div>
  </div>
</nav>

      <div class="tc-l pv3 ph3 ph4-ns">
        <h1 class="f2 f-subheadline-l fw2 light-silver mb0 lh-title">
          Posts
        </h1>
        
      </div>
    </div>
  </header>


    <main class="pb7" role="main">
      
  <article class="pa3 pa4-ns nested-copy-line-height nested-img">
    <section class="cf ph3 ph5-l pv3 pv4-l f4 tc-l center measure-wide lh-copy mid-gray"></section>
    <section class="flex-ns flex-wrap justify-around mt5">
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://xuepan-summer.github.io/summer-xuepan.github.io/posts/comparale%E5%8F%8Acomparator%E5%AF%B9%E6%AF%94/" class="link black dim">
        Comparable及Comparator对比
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      comparable接口:
public interface Comparable { int compareTo(Object other); } public interface Comparable&lt;T&gt; { int compareTo(&lt;T&gt; other); } 实现该接口的类必须要覆写compareTo方法
comparator接口:
public interface Comparator&lt;T&gt;{ int compare(T first,T second) } 实现该接口的类必须要覆写compare方法
if (user1.getAge() &gt; user2.getAge()) { return 1; } if (user1.getAge() &lt; user2.getAge()) { return -1; } return 0; 代码可以简化为：
return Integer.compare(user1.getAge(), user2.getAge()); Collections.sort(userList, new Comparator&lt;User&gt;() { @Override public int compare(User user1, User user2) { return Integer.compare(user1.getAge(), user2.getAge()); } }); //声明一个匿名内部类，覆写了Comparator接口的compare方法，里面定义了比较的标准 可以简化为：
Collections.sort(userList, (user1, user2) -&gt; Integer.
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://xuepan-summer.github.io/summer-xuepan.github.io/posts/arraylist%E6%89%A9%E5%AE%B9/" class="link black dim">
        ArrayList扩容
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      总结： ArrayList的底层是Object数组，默认容量为10，当往ArrayList里添加数据的时候，才会进行扩容。扩容主要由grow方法实现，扩容为之前的1.5倍左右，然后将之前的数据放到新数组里。
private static final int DEFAULT_CAPACITY = 10; private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}; transient Object[] elementData; // non-private to simplify nested class access 一、3种构造方法：
1.无参构造
public ArrayList() { this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; } 默认是一个空Object数组
2.集合作为参数的构造方法
public ArrayList(Collection&lt;? extends E&gt; c) { elementData = c.toArray(); if ((size = elementData.length) != 0) { // c.toArray might (incorrectly) not return Object[] (see 6260652)  if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://xuepan-summer.github.io/summer-xuepan.github.io/posts/push%E5%A4%B1%E8%B4%A5/" class="link black dim">
        IDEA push失败 Unable to access &#39;https://github.com/XXX/&#39;: Operation timed out ...
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
       出错原因  应该是网速太慢，所以push超时。
 操作    （pull的命令行格式是：git pull ）
在终端Terminal里输入git pull origin master &ndash;allow-unrelated-histories**（注意前面是两个‘-’，后面是一个‘-’）**
  该命令表示从远程仓库的origin分支拉取到本地的master分支
&ndash;allow-unrelated-histories的意思是允许合并不相关的历史，所以会进行强行合并
之后再次push即可，可以使用VCS-&gt;Git-&gt;Push进行push  
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://xuepan-summer.github.io/summer-xuepan.github.io/posts/%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E4%B8%89/" class="link black dim">
        实现生产者消费者(三)：BlockingQueue
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      生产者-消费者模型介绍  生产者和消费者同一时间使用同一存储空间，生产者往空间里放东西，消费者从空间里拿东西
现在要实现的是：生产者生产十个随机数供消费者使用，消费者依次消耗十个随机数，相当于生产者生产一个随机数，就放在盘子里，然后消费者消费。生产者再生产，消费者再消费，直至十个随机数被消耗完，整个过程结束。
采用BlockingQueue方法  BlockingQueue是接口，顾名思义，就是阻塞队列，队列中有空位才插入元素，队列中有元素才移除元素。
offer() &amp; put()
boolean offer(E e);若可以成功添加，返回true，否则返回false &ndash;&gt;非阻塞
boolean offer(E e, long timeout, TimeUnit unit) throws InterruptedException;
设定等待时间，如果指定时间内，还不能往队列中加入元素，则返回false &ndash;&gt;阻塞
void put(E e) throws InterruptedException;是阻塞的，如果队列内无空位，则一直等待，直到有空位才往队列中插入元素 &ndash;&gt;阻塞
poll() &amp; take()
E poll(long timeout, TimeUnit unit) throws InterruptedException;取出队首元素，可取出就直接返回，否则等待，超时还未取出则失败
E take() throws InterruptedException;取出队首元素，阻塞等待直到可取出
JDK文档的注释中有相关使用范例代码，如下所示：
class BoundedBuffer { final Lock lock = new ReentrantLock(); final Condition notFull = lock.newCondition(); final Condition notEmpty = lock.newCondition(); final Object[] items = new Object[100]; int putptr, takeptr, count; public void put(Object x) throws InterruptedException { lock.
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://xuepan-summer.github.io/summer-xuepan.github.io/posts/%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E4%BA%8C/" class="link black dim">
        实现生产者消费者(二)：Lock &amp; Condition
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      生产者-消费者模型介绍  生产者和消费者同一时间使用同一存储空间，生产者往空间里放东西，消费者从空间里拿东西
现在要实现的是：生产者生产十个随机数供消费者使用，消费者依次消耗十个随机数，相当于生产者生产一个随机数，就放在盘子里，然后消费者消费。生产者再生产，消费者再消费，直至十个随机数被消耗完，整个过程结束。
采用Lock &amp; Condition方法  Lock是接口，里面有lock()方法和unlock()方法，除此之外，还有tryLock()方法、newCondition()方法等。相比于synchronized更加灵活，因为synchronized默认在出作用域的时候释放资源，相当于解锁。所以Lock可以更加灵活地控制何时上锁，何时解锁。
Condition也是接口，主要是await()方法和signal()/signalAll()方法。signal()方法会唤醒一个正在等待该Condition的线程，而signalAll()方法会唤醒所有正在等待该Condition的线程。
JDK文档的注释中有相关使用范例代码，如下所示：
class BoundedBuffer { final Lock lock = new ReentrantLock(); final Condition notFull = lock.newCondition(); final Condition notEmpty = lock.newCondition(); final Object[] items = new Object[100]; int putptr, takeptr, count; public void put(Object x) throws InterruptedException { lock.lock(); try { while (count == items.length) notFull.await(); items[putptr] = x; if (++putptr == items.length) putptr = 0; ++count; notEmpty.signal(); } finally { lock.
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://xuepan-summer.github.io/summer-xuepan.github.io/posts/%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E4%B8%80/" class="link black dim">
        实现生产者消费者(一)：wait() &amp; notify()
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      生产者-消费者模型介绍  生产者和消费者同一时间使用同一存储空间，生产者往空间里放东西，消费者从空间里拿东西
现在要实现的是：生产者生产十个随机数供消费者使用，消费者依次消耗十个随机数，相当于生产者生产一个随机数，就放在盘子里，然后消费者消费。生产者再生产，消费者再消费，直至十个随机数被消耗完，整个过程结束。
采用Object.wait() &amp; notify()/notifyAll()方法  wait()表示让该线程等待
notify()/notifyAll()
Wakes up a single thread that is waiting on this object's monitor. If any threads are waiting on this object, one of them is chosen to be awakened. The choice is arbitrary and occurs at the discretion of the implementation. A thread waits on an object's monitor by calling one of the {@code wait} methods. notify()会随机唤醒一个等待该资源的线程
Wakes up all threads that are waiting on this object's monitor.
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://xuepan-summer.github.io/summer-xuepan.github.io/posts/stream%E6%80%BB%E7%BB%93%E5%8F%8Acollections.sort%E6%96%B9%E6%B3%95%E5%BA%94%E7%94%A8/" class="link black dim">
        Stream总结 &amp; Collections.sort()应用
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      学习了Stream之后，打算把Stream如何使用总结一下，便于下次翻阅。
一、Stream的创建操作、中间操作和终结操作 创建操作产生Stream
①某collection.stream()
②某stream.of()
③某string.chars()
④IntStream.range() 左闭右开
中间操作仍返回Stream
①filter() 过滤
②map() 映射
eg:map(User::getName)【方法引用】
③sorted()
eg:sorted(Comparator.comparing(某字段).thenComparing(某字段))
终结操作返回非Stream，包括void
①forEach()
②count()/max()/min()
③findFirst()/findAny
④anyMatch()/noneMatch()
collect()※ 是最常用的
Collectors.toList/toSet/toCollection
eg:Collectors.toCollection(TreeSet::new)
Collectors.groupingBy() 分组
eg:Collectors.groupingBy(Employee::getDepartment)
Collectors.joining() 连接
eg:Collectors.joining(&quot;, &ldquo;)
Collectors.summingInt() 累加求和
eg:Collectors.summingInt(Employee::getSalary)
二、Collections.sort()应用 1.包含两种传参方法
Collections.sort(list)
Collections.sort(list,Comparator)
2.java8新特性结合Collections.sort()
根据User的name对users(User类型的List)进行排序
有以下三种方法：
1.Comparator可以写成匿名内部类，实现compare方法
//1. Collections.sort(users, new Comparator&lt;User&gt;() { @Override public int compare(User user1, User user2) { return user1.getName().compareTo(user2.getName()); } }); 2.Comparator可以写成lambda表达式，如果写return的话需要加分号！
2.1是加上了参数类型的，参数表的参数类型可以忽略，如2.2所示
//2.1 复杂 Collections.sort(users, (User user1, User user2) -&gt; { return user1.
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://xuepan-summer.github.io/summer-xuepan.github.io/posts/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/" class="link black dim">
        Linux常用命令总结
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      平时工作中有时候会用到一些常用的Linux命令，所以打算整理一下，便于翻阅，后续再补充
  目录切换命令
 pwd 查看当前路径    cd 目录名 切换到指定目录下
【cd命令系列】  cd ../ 切换到上级目录
  cd / 切换到根目录（所有用户共享的目录）
  cd ~ 切换到用户主目录，root用户相当于cd /root；普通用户相当于cd /home/当前用户名
  cd - 切换到上一个所在目录（此目录之前所在目录）
      目录或文件操作命令
  ls 显示不隐藏的文件或文件夹
  ls -a 显示当前目录下所有文件及文件夹，包括隐藏的.和..
  ls -l 显示不隐藏的文件与文件夹的详细信息 =&gt;即 ll
  mkdir 目录名 创建目录
  touch 文件名 新建文件
【mv命令系列】  mv 旧文件 新文件 对文件重命名
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://xuepan-summer.github.io/summer-xuepan.github.io/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" class="link black dim">
        多线程
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      为什么需要多线程？    硬件需要：
CPU与其他设备的速度不同步，CPU很快，等执行完之后就进行等待，而且现在CPU大多是多核的，速度更快了。希望可以让CPU使用更加充分。
  程序需要：
java的执行模型是同步/阻塞的：默认是单线程，在执行的过程中，执行完第一行再执行第二行，一步一步来。假如第一行是执行一个很慢的方法，那么就会等这个方法执行结束再继续，这样就需要等待很久。
    多线程的过程
默认执行main线程，假如新开了线程a并start，那么就增加了一个执行流，main线程和线程a都有其私有的方法栈。
  start &amp; run 的区别
  start相当于main线程（老板）给新线程（工人）分配完了之后就让工人自己去干活了，自己继续去做自己的事情。
  run相当于main线程（老板）给新线程（工人）分配了活并进行监工，等工人干完活之后再去做自己的事情。
如果让新线程执行run方法的话，和没有分多线程是一样的效果！！！只有start才可以并发执行！
    多线程会产生什么问题？
同一份代码，不同人乱序运行，如果不是原子操作（某一时刻只能被一个线程操作），那么就会时好时坏，有时就会出错
例子：i 初始值为0，线程a和线程b都执行同一方法中的i++操作
理想正确场景：线程a执行时 i 加1，变成1；线程b执行时 i 再加1，变成2（即使顺序调换，先线程b再线程a，结果也还是2）
实际报错场景：i++分为三步：
(1) 取出 i 的值
(2) i 的值加 1
(3) 将叠加之后的值给 i
假设线程a先占用了CPU，取出 i 的初始值0，然后 i 加1变成了1。但是！此时线程a占用CPU的时间到了，所以轮到了线程b，由于线程a还没将数据赋值给 i ，所以 i 的值还是0，线程2成功在其基础上加1并赋值给 i ，那么 i 就变成了1。接下来又轮到了线程a，线程a直接将刚刚叠加之后的结果1赋值给 i 。最终结果就变成了 1 而不是2。 如下图所示。
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://xuepan-summer.github.io/summer-xuepan.github.io/posts/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/" class="link black dim">
        深拷贝与浅拷贝
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      Home里定义了Cat
public class Home { public Cat cat; public Home(Cat cat) { this.cat = cat; } } Cat有其名字
public class Cat { public String name; public Cat(String name) { this.name = name; } } 在Main方法中定义一个Home类型的对象，对其进行拷贝
Home home = new Home(new Cat(&#34;Tom&#34;)); 相当于将名为Tom的猫放在Home里
在这个具体的例子中，
浅拷贝：将这只名为Tom的猫也放到新房子里
深拷贝：重新定义一只名为Tom的猫，将其放到新房子里
public static Home shallowCopy(Home home) { Home newHome = new Home(home.cat); return newHome; //此处只为方便理解，建议直接return new Home(home.cat); } home.cat就是刚开始home对象里的猫，然后通过构造器将其直接放到新建的newHome里面。
public static Home deepCopy(Home home) { Cat newCat = new Cat(home.
    </div>
  </div>
</div>
</div>
      
    </section>

<ul class="pagination">
    
    <li class="page-item">
        <a href="/summer-xuepan.github.io/posts/" class="page-link" aria-label="First"><span aria-hidden="true">&laquo;&laquo;</span></a>
    </li>
    
    <li class="page-item disabled">
    <a  class="page-link" aria-label="Previous"><span aria-hidden="true">&laquo;</span></a>
    </li>
    
    
    
    
    
    
    
        
        
    
    
    <li class="page-item active"><a class="page-link" href="/summer-xuepan.github.io/posts/">1</a></li>
    
    
    
    
    
    
        
        
    
    
    <li class="page-item"><a class="page-link" href="/summer-xuepan.github.io/posts/page/2/">2</a></li>
    
    
    <li class="page-item">
    <a href="/summer-xuepan.github.io/posts/page/2/" class="page-link" aria-label="Next"><span aria-hidden="true">&raquo;</span></a>
    </li>
    
    <li class="page-item">
        <a href="/summer-xuepan.github.io/posts/page/2/" class="page-link" aria-label="Last"><span aria-hidden="true">&raquo;&raquo;</span></a>
    </li>
    
</ul>

</article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://xuepan-summer.github.io/summer-xuepan.github.io/" >
    &copy;  Summer's Blog 2020 
  </a>
    <div>














</div>
  </div>
</footer>

    

  <script src="/summer-xuepan.github.io/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
