<!DOCTYPE html>
<html lang="zh-Hans">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Summer&#39;s Blog</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.69.2" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
    
      <link href="/summer-xuepan.github.io/dist/css/app.4fc0b62e4b82c997bb0041217cd6b979.css" rel="stylesheet">
    

    

    
      

    

    
    
      <link href="/summer-xuepan.github.io/posts/index.xml" rel="alternate" type="application/rss+xml" title="Summer&#39;s Blog" />
      <link href="/summer-xuepan.github.io/posts/index.xml" rel="feed" type="application/rss+xml" title="Summer&#39;s Blog" />
      
    
    
    <meta property="og:title" content="Posts" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://xuepan-summer.github.io/summer-xuepan.github.io/posts/" />
<meta property="og:updated_time" content="2021-01-26T16:59:56+08:00" />
<meta itemprop="name" content="Posts">
<meta itemprop="description" content=""><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Posts"/>
<meta name="twitter:description" content=""/>

	
  </head>

  <body class="ma0 avenir bg-near-white">

    

  <header>
    <div class="pb3-m pb6-l bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/summer-xuepan.github.io/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        Summer&#39;s Blog
      
    </a>
    <div class="flex-l items-center">
      

      
      















    </div>
  </div>
</nav>

      <div class="tc-l pv3 ph3 ph4-ns">
        <h1 class="f2 f-subheadline-l fw2 light-silver mb0 lh-title">
          Posts
        </h1>
        
      </div>
    </div>
  </header>


    <main class="pb7" role="main">
      
  <article class="pa3 pa4-ns nested-copy-line-height nested-img">
    <section class="cf ph3 ph5-l pv3 pv4-l f4 tc-l center measure-wide lh-copy mid-gray"></section>
    <section class="flex-ns flex-wrap justify-around mt5">
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://xuepan-summer.github.io/summer-xuepan.github.io/posts/comparable%E5%8F%8Acomparator%E5%AF%B9%E6%AF%94/" class="link black dim">
        Comparable及Comparator对比
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      comparable接口:
public interface Comparable { int compareTo(Object other); } public interface Comparable&lt;T&gt; { int compareTo(&lt;T&gt; other); } 实现该接口的类必须要覆写compareTo方法
comparator接口:
public interface Comparator&lt;T&gt;{ int compare(T first,T second) } 实现该接口的类必须要覆写compare方法
if (user1.getAge() &gt; user2.getAge()) { return 1; } if (user1.getAge() &lt; user2.getAge()) { return -1; } return 0; 代码可以简化为：
return Integer.compare(user1.getAge(), user2.getAge()); Collections.sort(userList, new Comparator&lt;User&gt;() { @Override public int compare(User user1, User user2) { return Integer.compare(user1.getAge(), user2.getAge()); } }); //声明一个匿名内部类，覆写了Comparator接口的compare方法，里面定义了比较的标准 可以简化为：
Collections.sort(userList, (user1, user2) -&gt; Integer.
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://xuepan-summer.github.io/summer-xuepan.github.io/posts/arraylist%E6%89%A9%E5%AE%B9%E4%B9%8B%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" class="link black dim">
        ArrayList扩容之源码剖析
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      总结： ArrayList的底层是Object数组，默认容量为10，当往ArrayList里添加数据的时候，才会进行扩容。扩容主要由grow方法实现，扩容为之前的1.5倍左右，然后将之前的数据放到新数组里。
private static final int DEFAULT_CAPACITY = 10; private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}; transient Object[] elementData; // non-private to simplify nested class access 一、3种构造方法：
1.无参构造
public ArrayList() { this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; } 默认是一个空Object数组
2.集合作为参数的构造方法
public ArrayList(Collection&lt;? extends E&gt; c) { elementData = c.toArray(); if ((size = elementData.length) != 0) { // c.toArray might (incorrectly) not return Object[] (see 6260652)  if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://xuepan-summer.github.io/summer-xuepan.github.io/posts/push%E5%A4%B1%E8%B4%A5/" class="link black dim">
        IDEA push失败 Unable to access &#39;https://github.com/XXX/&#39;: Operation timed out ...
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
       出错原因  应该是网速太慢，所以push超时。
 操作    （pull的命令行格式是：git pull ）
在终端Terminal里输入git pull origin master &ndash;allow-unrelated-histories**（注意前面是两个‘-’，后面是一个‘-’）**
  该命令表示从远程仓库的origin分支拉取到本地的master分支
&ndash;allow-unrelated-histories的意思是允许合并不相关的历史，所以会进行强行合并
之后再次push即可，可以使用VCS-&gt;Git-&gt;Push进行push  
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://xuepan-summer.github.io/summer-xuepan.github.io/posts/%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E4%B8%89/" class="link black dim">
        实现生产者消费者(三)：BlockingQueue
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      生产者-消费者模型介绍  生产者和消费者同一时间使用同一存储空间，生产者往空间里放东西，消费者从空间里拿东西
现在要实现的是：生产者生产十个随机数供消费者使用，消费者依次消耗十个随机数，相当于生产者生产一个随机数，就放在盘子里，然后消费者消费。生产者再生产，消费者再消费，直至十个随机数被消耗完，整个过程结束。
采用BlockingQueue方法  BlockingQueue是接口，顾名思义，就是阻塞队列，队列中有空位才插入元素，队列中有元素才移除元素。
offer() &amp; put()
boolean offer(E e);若可以成功添加，返回true，否则返回false &ndash;&gt;非阻塞
boolean offer(E e, long timeout, TimeUnit unit) throws InterruptedException;
设定等待时间，如果指定时间内，还不能往队列中加入元素，则返回false &ndash;&gt;阻塞
void put(E e) throws InterruptedException;是阻塞的，如果队列内无空位，则一直等待，直到有空位才往队列中插入元素 &ndash;&gt;阻塞
poll() &amp; take()
E poll(long timeout, TimeUnit unit) throws InterruptedException;取出队首元素，可取出就直接返回，否则等待，超时还未取出则失败
E take() throws InterruptedException;取出队首元素，阻塞等待直到可取出
JDK文档的注释中有相关使用范例代码，如下所示：
class BoundedBuffer { final Lock lock = new ReentrantLock(); final Condition notFull = lock.newCondition(); final Condition notEmpty = lock.newCondition(); final Object[] items = new Object[100]; int putptr, takeptr, count; public void put(Object x) throws InterruptedException { lock.
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://xuepan-summer.github.io/summer-xuepan.github.io/posts/%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E4%BA%8C/" class="link black dim">
        实现生产者消费者(二)：Lock &amp; Condition
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      生产者-消费者模型介绍  生产者和消费者同一时间使用同一存储空间，生产者往空间里放东西，消费者从空间里拿东西
现在要实现的是：生产者生产十个随机数供消费者使用，消费者依次消耗十个随机数，相当于生产者生产一个随机数，就放在盘子里，然后消费者消费。生产者再生产，消费者再消费，直至十个随机数被消耗完，整个过程结束。
采用Lock &amp; Condition方法  Lock是接口，里面有lock()方法和unlock()方法，除此之外，还有tryLock()方法、newCondition()方法等。相比于synchronized更加灵活，因为synchronized默认在出作用域的时候释放资源，相当于解锁。所以Lock可以更加灵活地控制何时上锁，何时解锁。
Condition也是接口，主要是await()方法和signal()/signalAll()方法。signal()方法会唤醒一个正在等待该Condition的线程，而signalAll()方法会唤醒所有正在等待该Condition的线程。
JDK文档的注释中有相关使用范例代码，如下所示：
class BoundedBuffer { final Lock lock = new ReentrantLock(); final Condition notFull = lock.newCondition(); final Condition notEmpty = lock.newCondition(); final Object[] items = new Object[100]; int putptr, takeptr, count; public void put(Object x) throws InterruptedException { lock.lock(); try { while (count == items.length) notFull.await(); items[putptr] = x; if (++putptr == items.length) putptr = 0; ++count; notEmpty.signal(); } finally { lock.
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://xuepan-summer.github.io/summer-xuepan.github.io/posts/%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E4%B8%80/" class="link black dim">
        实现生产者消费者(一)：wait() &amp; notify()
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      生产者-消费者模型介绍  生产者和消费者同一时间使用同一存储空间，生产者往空间里放东西，消费者从空间里拿东西
现在要实现的是：生产者生产十个随机数供消费者使用，消费者依次消耗十个随机数，相当于生产者生产一个随机数，就放在盘子里，然后消费者消费。生产者再生产，消费者再消费，直至十个随机数被消耗完，整个过程结束。
采用Object.wait() &amp; notify()/notifyAll()方法  wait()表示让该线程等待
notify()/notifyAll()
Wakes up a single thread that is waiting on this object's monitor. If any threads are waiting on this object, one of them is chosen to be awakened. The choice is arbitrary and occurs at the discretion of the implementation. A thread waits on an object's monitor by calling one of the {@code wait} methods. notify()会随机唤醒一个等待该资源的线程
Wakes up all threads that are waiting on this object's monitor.
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://xuepan-summer.github.io/summer-xuepan.github.io/posts/stream%E6%80%BB%E7%BB%93%E5%8F%8Acollections.sort%E6%96%B9%E6%B3%95%E5%BA%94%E7%94%A8/" class="link black dim">
        Stream总结 &amp; Collections.sort()应用
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      学习了Stream之后，打算把Stream如何使用总结一下，便于下次翻阅。
一、Stream的创建操作、中间操作和终结操作 创建操作产生Stream
①某collection.stream()
②某stream.of()
③某string.chars()
④IntStream.range() 左闭右开
中间操作仍返回Stream
①filter() 过滤
②map() 映射
eg:map(User::getName)【方法引用】
③sorted()
eg:sorted(Comparator.comparing(某字段).thenComparing(某字段))
终结操作返回非Stream，包括void
①forEach()
②count()/max()/min()
③findFirst()/findAny
④anyMatch()/noneMatch()
collect()※ 是最常用的
Collectors.toList/toSet/toCollection
eg:Collectors.toCollection(TreeSet::new)
Collectors.groupingBy() 分组
eg:Collectors.groupingBy(Employee::getDepartment)
Collectors.joining() 连接
eg:Collectors.joining(&quot;, &ldquo;)
Collectors.summingInt() 累加求和
eg:Collectors.summingInt(Employee::getSalary)
二、Collections.sort()应用 1.包含两种传参方法
Collections.sort(list)
Collections.sort(list,Comparator)
2.java8新特性结合Collections.sort()
根据User的name对users(User类型的List)进行排序
有以下三种方法：
1.Comparator可以写成匿名内部类，实现compare方法
//1. Collections.sort(users, new Comparator&lt;User&gt;() { @Override public int compare(User user1, User user2) { return user1.getName().compareTo(user2.getName()); } }); 2.Comparator可以写成lambda表达式，如果写return的话需要加分号！
2.1是加上了参数类型的，参数表的参数类型可以忽略，如2.2所示
//2.1 复杂 Collections.sort(users, (User user1, User user2) -&gt; { return user1.
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://xuepan-summer.github.io/summer-xuepan.github.io/posts/treeset%E8%B8%A9%E5%9D%91/" class="link black dim">
        TreeSet踩坑
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      1.Set &amp; TreeSet
 Set：通过HashSet()及equals()达到无序去重的目的 TreeSet：通过实现Comparable接口的CompareTo()方法达到有序去重的目的  2.TreeSet可能遇到的问题
eg:User有两个属性，id和name，
如果只针对于name进行判断，将User存到list中。那么ComapreTo()方法如果重名的User，即使id不同，TreeSet也不会区分出来，仍然认为是同一个User所以使用TreeSet的时候，必须把去重条件写清楚！！！
public class User implements Comparable&lt;User&gt; { /** * 用户ID，数据库主键，全局唯一 */ private final Integer id; /** * 用户名 */ private final String name; public User(Integer id, String name) { this.id = id; this.name = name; } public Integer getId() { return id; } public String getName() { return name; } @Override public boolean equals(Object o) { if (this == o) { return true; } if (o == null || getClass() !
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://xuepan-summer.github.io/summer-xuepan.github.io/posts/%E5%B8%B8%E7%94%A8jvm%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/" class="link black dim">
        常用JVM分析工具
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      项目里出现了full GC问题之后，当时使用了Visual VM这种可视化工具发现了问题所在，但是日常开发也不能拘泥于这一种工具，还是应该多看看其他的工具，结合着使用，毕竟工具各有利弊。所以把这些工具和作用总结一下，便于使用时查阅。
常见jdk工具（命令行）  jps（JVM Process Status Tool）获取java进程的ID
  jstat（JVM Statistics Monitoring Tool）监视java进程的运行状态信息
  jinfo（Configuration Info for Java）获取java进程的配置信息，包括JVM的配置信息和系统属性
  jmap（Memory Map for Java）查看堆的使用情况且完成堆到文件的一个转储
  jhat（JVM Heap Dump Broswer）分析用jmap转储的二进制文件，通过浏览器可以查看jhat分析的结果
  jstack（Stack Trace for Java）查看应用程序的堆栈信息
  常见jdk工具（可视化）其实就是将上述的这个工具组合起来，以图形化页面展示出来
  JConsole
  Visual VM（1.5之后jdk已经自带了，可以直接使用，又名jVisual VM [java visual VM] ）
  使用工具是为了帮助我们发现问题，而在解决问题的时候，主要分析以下两点：内存分析和线程分析，分析具体又包括这四个方面&ndash;监视、转储、快照和性能分析
监视：看CPU使用情况、内存使用情况、线程状态及其他信息，例如JConsole、Visual VM、JStack都可以
转储：从内存中获取当前状态数据并转储到文件，用于进行静态的性能分析
包括系统转储、Java转储、堆转储
  系统转储：又称核心转储，一般使用相关工具，例如Windows的windbg和Linux的gdb
  Java转储：JVM内部生成的格式化的数据，包括线程信息，类的加载信息，堆的统计数据等，通常用于检测死锁
  堆转储：所有对象的堆内容
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://xuepan-summer.github.io/summer-xuepan.github.io/posts/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/" class="link black dim">
        Linux常用命令总结
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      平时工作中有时候会用到一些常用的Linux命令，所以打算整理一下，便于翻阅，后续再补充
  目录切换命令
 pwd 查看当前路径    cd 目录名 切换到指定目录下
【cd命令系列】  cd .当前目录
  cd ../ 切换到上级目录
  cd / 切换到根目录（所有用户共享的目录）
  cd ~ 切换到用户主目录，root用户相当于cd /root；普通用户相当于cd /home/当前用户名
  cd - 切换到上一个所在目录（此目录之前所在目录）
      目录或文件操作命令
  ls 显示不隐藏的文件或文件夹
  ls -a 显示当前目录下所有文件及文件夹，包括隐藏的.和.. a表示all
  ls -l 显示不隐藏的文件与文件夹的详细信息 =&gt;即 ll l表示list
  ls -h 以方便阅读的形式展示，不再以字节显示，以大小，例如kb显示 h代表human
    </div>
  </div>
</div>
</div>
      
    </section>

<ul class="pagination">
    
    <li class="page-item">
        <a href="/summer-xuepan.github.io/posts/" class="page-link" aria-label="First"><span aria-hidden="true">&laquo;&laquo;</span></a>
    </li>
    
    <li class="page-item">
    <a href="/summer-xuepan.github.io/posts/" class="page-link" aria-label="Previous"><span aria-hidden="true">&laquo;</span></a>
    </li>
    
    
    
    
    
    
    
        
        
    
    
    <li class="page-item"><a class="page-link" href="/summer-xuepan.github.io/posts/">1</a></li>
    
    
    
    
    
    
        
        
    
    
    <li class="page-item active"><a class="page-link" href="/summer-xuepan.github.io/posts/page/2/">2</a></li>
    
    
    
    
    
    
        
        
    
    
    <li class="page-item"><a class="page-link" href="/summer-xuepan.github.io/posts/page/3/">3</a></li>
    
    
    <li class="page-item">
    <a href="/summer-xuepan.github.io/posts/page/3/" class="page-link" aria-label="Next"><span aria-hidden="true">&raquo;</span></a>
    </li>
    
    <li class="page-item">
        <a href="/summer-xuepan.github.io/posts/page/3/" class="page-link" aria-label="Last"><span aria-hidden="true">&raquo;&raquo;</span></a>
    </li>
    
</ul>

</article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://xuepan-summer.github.io/summer-xuepan.github.io/" >
    &copy;  Summer's Blog 2021 
  </a>
    <div>














</div>
  </div>
</footer>

    

  <script src="/summer-xuepan.github.io/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
