<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Summer&#39;s Blog</title>
    <link>https://xuepan-summer.github.io/summer-xuepan.github.io/posts/</link>
    <description>Recent content in Posts on Summer&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-Hans</language>
    <lastBuildDate>Tue, 12 Jan 2021 11:16:15 +0800</lastBuildDate>
    
	<atom:link href="https://xuepan-summer.github.io/summer-xuepan.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>正则表达式和String常用API的碰撞</title>
      <link>https://xuepan-summer.github.io/summer-xuepan.github.io/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8Cstring%E5%B8%B8%E7%94%A8api%E7%9A%84%E7%A2%B0%E6%92%9E/</link>
      <pubDate>Tue, 12 Jan 2021 11:16:15 +0800</pubDate>
      
      <guid>https://xuepan-summer.github.io/summer-xuepan.github.io/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8Cstring%E5%B8%B8%E7%94%A8api%E7%9A%84%E7%A2%B0%E6%92%9E/</guid>
      <description>最近工作上有遇到一个需要截取想要的字符串的情况，第一时间想到了正则表达式，后来用着用着，发现String的API真是太好用了，还比正则简单一些，记录一下心得。
当时的场景是需要截取全限定类名，大概格式是这样的：
AuthController可以认为是类名，login()是方法名
原结果 public java.lang.String org.XXX.XXX.web.xxx.AuthController.login()
所需结果 org.XXX.XXX.web.xxx.AuthController
也就是要从org开始取，取到类名结束
这个时候String的API就开始大显神通了，主要用到了split(char ch)、substring(startIndex , endIndex)、lastIndexOf(String str)
先用空格截取成三部分，最后一部分就是全限定类名加方法，通过左括号进行截取，再通过.进行截取，这样就得到最终结果了。
String[] strArray = str.split(&amp;#34; &amp;#34;); String methodName = strArray[strArray.length -1]; String bracketLeft = methodName.substring(0, methodName.lastIndexOf(&amp;#39;(&amp;#39;)); //此处为单引号！ String fullQualClassName = bracketLeft.substring(0, bracketLeft.lastIndexOf(&amp;#39;.&amp;#39;)); PS：split方法如果传参为“|” “.”等特殊字符的时候，一定要记得//转义这个地方就有踩坑，可以跑一个main方法检验一下，节省时间，这样就不会发布之后才发现有问题常用的String API总结在这，有遗忘再翻阅
字符数组相关：
index从0开始
字节数组相关：
字符串比较：
字符串查找：
字符串替换：
字符串截取：
endIndex不包含该位，不可以是负数
字符串拆分：
如果用&amp;rdquo;&amp;quot;(空字符串)拆分，则按照每个字符进行拆分
如果敏感字符拆不了，则用转义字符
其他方法：
用户进行数据输入时可能有无用的空格内容&amp;ndash;trim
某些情况下要求用户输入的数据长度有限制，用此方式判断&amp;ndash;length
注：数组对象.length; String 对象.length(); 一个有括号，一个没有如果isEmpty()不方便，可以使用&amp;rdquo;&amp;quot;.equals(str)
String类少了一个重要方法initcap()功能，首字母大写，其余字母小写</description>
    </item>
    
    <item>
      <title>代码重构感想总结</title>
      <link>https://xuepan-summer.github.io/summer-xuepan.github.io/posts/%E4%BB%A3%E7%A0%81%E9%87%8D%E6%9E%84%E6%84%9F%E6%83%B3%E6%80%BB%E7%BB%93/</link>
      <pubDate>Thu, 31 Dec 2020 16:35:56 +0800</pubDate>
      
      <guid>https://xuepan-summer.github.io/summer-xuepan.github.io/posts/%E4%BB%A3%E7%A0%81%E9%87%8D%E6%9E%84%E6%84%9F%E6%83%B3%E6%80%BB%E7%BB%93/</guid>
      <description>做项目的过程中自己负责的模块传参很多，sonar也会不断报错参数超过七个，提示最好缩减到七个以内，所以在写代码的时候就稍微注意一些，争取在写代码的过程中就重构一下，使代码更加通俗易懂。
以下是总结出来的代码重构需要注意的问题，后续再多多补充：
1.命名参数和方法名时，争取一看到就知道参数是什么含义，方法到底做了什么
2.争取一个方法只做一件事情
eg:整个流程分为 判断是否符合前置条件&amp;ndash;插入到中间表&amp;ndash;处理符合条件的票
所以分成三步
具体实现中：
①所有对前置条件的处理放在一个方法里，里面可以再细分
可以复用方法，减少代码，如果还需后续处理，那么可以采用lambda表达式
②插入数据至中间表放在一个方法里
可以采用CollectionUtils.isEmpty()/isNotEmpty()等工具类里的方法
整个流程不要有大块的分支，if每多一层，复杂度就越高。例如不推荐一个很大的if块，可以采用反面，不符合条件就直接return
if (CollectionUtils.isEmpty(effectiveTax)) { return; } 不推荐使用非!，特别不方便理解，而且带非的和&amp;amp;&amp;amp; || 这些一结合，还有执行先后顺序的问题
将带非的逻辑转换一下就行，实在不行将这部分抽取成一个方法
③处理符合条件的票放在一个方法里
3.双层for循环或者更多层的for循环，最好减少循环次数
当时双层for循环在debug的时候发现了问题，生成了两条TDS记录，是因为第一次for循环是对中间表中所有符合条件的数据进行循环，第二次循环是根据seq进行判断，有两个seq，所以循环了两次，所以生成了两条 双层for循环最好修改成for+for
4.最好不要使用匿名内部类，因为一旦出现问题，不方便查找
5.传递参数过多时：
看看每个参数都是在方法里面哪部分用的，然后分类放在一起，看看能不能根据参数把方法再抽取一下；还可以采用provider、entity、vo等来简化参数
6.复用已有方法，需要进行部分修改的时候，一定要查看该方法的调用，避免因为自己的修改导致其他功能受到影响</description>
    </item>
    
    <item>
      <title>Object转String的三种方法总结</title>
      <link>https://xuepan-summer.github.io/summer-xuepan.github.io/posts/object%E8%BD%ACstring%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</link>
      <pubDate>Thu, 31 Dec 2020 16:32:00 +0800</pubDate>
      
      <guid>https://xuepan-summer.github.io/summer-xuepan.github.io/posts/object%E8%BD%ACstring%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</guid>
      <description>在项目里遇到了将Object数组里的内容分别转换成所需类型的问题，发现Object转String可没有想象的那么简单，还需要考虑到null的情况，所以好好总结了一下。
 Object.toString()  Object类里的toString()方法是每个继承了Object的类都有的，可以覆写，使得每个类有自己的toString实现
如果对象为null，会抛出NullPointerException，因为null不能再去调用方法或者变量了
(String)Object  强制类型转换
这个object对象必须能够转换成String类型，否则会抛异常ClassCastException
String.valueOf(Object)  即使object为null，也不会有问题
public static String valueOf(Object obj) { return (obj == null) ? &amp;quot;null&amp;quot; : obj.toString(); } 注意：如果真的是空对象，会返回“null”而不是null</description>
    </item>
    
    <item>
      <title>Oracle数据库函数总结</title>
      <link>https://xuepan-summer.github.io/summer-xuepan.github.io/posts/oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93/</link>
      <pubDate>Fri, 18 Dec 2020 10:30:14 +0800</pubDate>
      
      <guid>https://xuepan-summer.github.io/summer-xuepan.github.io/posts/oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93/</guid>
      <description>将平时SQL中遇到的oracle数据函数总结一下，便于遗忘时翻阅
1.lpad &amp;amp; rpad
lpad(string,n,[pad&amp;hellip;string]) 给定字符左侧添加指定字符至长度n. rpad(string,n,[pad..string]) 给定字符右侧添加指定字符至长度n.
2.substr
substr(string, int a, int b) 给定字符串从位置 a(a为0或1时表示从第一个字符开始截取)开始 截取b长度个字符 substr(string,int a) 从位置a开始，一直截取给定字符串到串尾
3.decode
decode(条件，值1，返回值1，值2，返回值2，..值 n，返回值n，缺省值)&amp;rdquo; IF条件=值1 THEN RETURN 返回值1 ELSE IF条件=值2 THEN RETURN返回值2 &amp;hellip; ELSE IF条件=值n then RETURN返回值n ELSE RETURN 缺省值
4.nvl
nvl(string1, replace_with) 如果string1为null，则返回replace_with，否则返回string1</description>
    </item>
    
    <item>
      <title>命令查看oracle事务隔离级别</title>
      <link>https://xuepan-summer.github.io/summer-xuepan.github.io/posts/%E5%91%BD%E4%BB%A4%E6%9F%A5%E7%9C%8Boracle%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</link>
      <pubDate>Fri, 18 Dec 2020 10:10:34 +0800</pubDate>
      
      <guid>https://xuepan-summer.github.io/summer-xuepan.github.io/posts/%E5%91%BD%E4%BB%A4%E6%9F%A5%E7%9C%8Boracle%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</guid>
      <description>出于好奇，想看一下目前项目里oracle使用事务隔离级别是否是默认的，所以用命令验证了一下： 注：创建完之后先别commit，直接select即可选出数据
运行结果说明项目里目前没有修改oracle的事务隔离级别，仍然是默认的READ COMMITED读已提交</description>
    </item>
    
    <item>
      <title>浅谈事务</title>
      <link>https://xuepan-summer.github.io/summer-xuepan.github.io/posts/%E6%B5%85%E8%B0%88%E4%BA%8B%E5%8A%A1/</link>
      <pubDate>Tue, 17 Nov 2020 14:43:30 +0800</pubDate>
      
      <guid>https://xuepan-summer.github.io/summer-xuepan.github.io/posts/%E6%B5%85%E8%B0%88%E4%BA%8B%E5%8A%A1/</guid>
      <description>浅谈事务(transaction)  事务的概念：  事务是DBMS（可靠数据库管理系统）中最基本的单位，通俗来讲就是要做的事情。包括四大特性（ACID）：Atomicity 原子性、Consistency 一致性、Isolation 隔离性、Durability持久性。
 事务四大特性：   原子性：事务是不可分割的整体，事务里的操作要么都实现要么都不实现，体现了原子性。  eg：甲给乙转钱，乙收钱，要么整个过程成功（甲扣钱，乙收钱），要么整个过程不成功（甲未扣钱，乙未收钱）。
 一致性：甲给乙转的钱和乙收到的钱是一致的。整个过程是维持平衡的。
  隔离性：事务之间是隔离的，即使不同事务处理相同的数据，也要有修改隔离。（即修改也是相互独立的）
  持久性：事务一旦提交，将持久保存在数据库中。
   事务高并发产生问题：    脏读(Dirty Read)：事务B读到了事务A已修改但未提交的数据。如果事务A提交失败，那么这B就读到了脏数据。
  不可重复读(Unrepeatable Read)：一个事务多次查询同一数据，结果不一致。因为受到了其他事务的干扰。
  幻读(Phantom Read)：例如事务A将1改成2，事务B插入了数据1，那么还是可以选出来值为1的数据
三者区别
① 脏读&amp;amp;不可重复读：脏读是因为修改未提交，但不可重复读是因为有别的事务插手，读取了其他事务提交的数据，所以数据不一致
② 不可重复读&amp;amp;幻读：不可重复读针对同一数据项，幻读针对一批数据整体（比如数据条数）
针对以上问题，隔离性就起了作用，如何使事务之间隔离起来，互不影响？因此产生了事务隔离级别。
   事务隔离级别：  ×表示不会出现，√表示可能会出现
   事务隔离级别 脏读 不可重复读 幻读     Read uncommitted √ √ √   Read committed × √ √   Repeatable read × × √   Serializable × × ×    ① Read uncommitted (读未提交)：最低的事务隔离级别，一个事务还没提交时，它做的变更就能被别的事务看到。</description>
    </item>
    
    <item>
      <title>Comparable及Comparator对比</title>
      <link>https://xuepan-summer.github.io/summer-xuepan.github.io/posts/comparable%E5%8F%8Acomparator%E5%AF%B9%E6%AF%94/</link>
      <pubDate>Mon, 16 Nov 2020 18:21:50 +0800</pubDate>
      
      <guid>https://xuepan-summer.github.io/summer-xuepan.github.io/posts/comparable%E5%8F%8Acomparator%E5%AF%B9%E6%AF%94/</guid>
      <description>comparable接口:
public interface Comparable { int compareTo(Object other); } public interface Comparable&amp;lt;T&amp;gt; { int compareTo(&amp;lt;T&amp;gt; other); } 实现该接口的类必须要覆写compareTo方法
comparator接口:
public interface Comparator&amp;lt;T&amp;gt;{ int compare(T first,T second) } 实现该接口的类必须要覆写compare方法
if (user1.getAge() &amp;gt; user2.getAge()) { return 1; } if (user1.getAge() &amp;lt; user2.getAge()) { return -1; } return 0; 代码可以简化为：
return Integer.compare(user1.getAge(), user2.getAge()); Collections.sort(userList, new Comparator&amp;lt;User&amp;gt;() { @Override public int compare(User user1, User user2) { return Integer.compare(user1.getAge(), user2.getAge()); } }); //声明一个匿名内部类，覆写了Comparator接口的compare方法，里面定义了比较的标准 可以简化为：
Collections.sort(userList, (user1, user2) -&amp;gt; Integer.</description>
    </item>
    
    <item>
      <title>ArrayList扩容之源码剖析</title>
      <link>https://xuepan-summer.github.io/summer-xuepan.github.io/posts/arraylist%E6%89%A9%E5%AE%B9%E4%B9%8B%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</link>
      <pubDate>Mon, 16 Nov 2020 18:17:35 +0800</pubDate>
      
      <guid>https://xuepan-summer.github.io/summer-xuepan.github.io/posts/arraylist%E6%89%A9%E5%AE%B9%E4%B9%8B%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</guid>
      <description>总结： ArrayList的底层是Object数组，默认容量为10，当往ArrayList里添加数据的时候，才会进行扩容。扩容主要由grow方法实现，扩容为之前的1.5倍左右，然后将之前的数据放到新数组里。
private static final int DEFAULT_CAPACITY = 10; private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}; transient Object[] elementData; // non-private to simplify nested class access 一、3种构造方法：
1.无参构造
public ArrayList() { this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; } 默认是一个空Object数组
2.集合作为参数的构造方法
public ArrayList(Collection&amp;lt;? extends E&amp;gt; c) { elementData = c.toArray(); if ((size = elementData.length) != 0) { // c.toArray might (incorrectly) not return Object[] (see 6260652)  if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].</description>
    </item>
    
    <item>
      <title>IDEA push失败 Unable to access &#39;https://github.com/XXX/&#39;: Operation timed out ...</title>
      <link>https://xuepan-summer.github.io/summer-xuepan.github.io/posts/push%E5%A4%B1%E8%B4%A5/</link>
      <pubDate>Mon, 16 Nov 2020 18:03:04 +0800</pubDate>
      
      <guid>https://xuepan-summer.github.io/summer-xuepan.github.io/posts/push%E5%A4%B1%E8%B4%A5/</guid>
      <description> 出错原因  应该是网速太慢，所以push超时。
 操作    （pull的命令行格式是：git pull ）
在终端Terminal里输入git pull origin master &amp;ndash;allow-unrelated-histories**（注意前面是两个‘-’，后面是一个‘-’）**
  该命令表示从远程仓库的origin分支拉取到本地的master分支
&amp;ndash;allow-unrelated-histories的意思是允许合并不相关的历史，所以会进行强行合并
之后再次push即可，可以使用VCS-&amp;gt;Git-&amp;gt;Push进行push  </description>
    </item>
    
    <item>
      <title>实现生产者消费者(三)：BlockingQueue</title>
      <link>https://xuepan-summer.github.io/summer-xuepan.github.io/posts/%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E4%B8%89/</link>
      <pubDate>Wed, 11 Nov 2020 15:15:11 +0800</pubDate>
      
      <guid>https://xuepan-summer.github.io/summer-xuepan.github.io/posts/%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E4%B8%89/</guid>
      <description>生产者-消费者模型介绍  生产者和消费者同一时间使用同一存储空间，生产者往空间里放东西，消费者从空间里拿东西
现在要实现的是：生产者生产十个随机数供消费者使用，消费者依次消耗十个随机数，相当于生产者生产一个随机数，就放在盘子里，然后消费者消费。生产者再生产，消费者再消费，直至十个随机数被消耗完，整个过程结束。
采用BlockingQueue方法  BlockingQueue是接口，顾名思义，就是阻塞队列，队列中有空位才插入元素，队列中有元素才移除元素。
offer() &amp;amp; put()
boolean offer(E e);若可以成功添加，返回true，否则返回false &amp;ndash;&amp;gt;非阻塞
boolean offer(E e, long timeout, TimeUnit unit) throws InterruptedException;
设定等待时间，如果指定时间内，还不能往队列中加入元素，则返回false &amp;ndash;&amp;gt;阻塞
void put(E e) throws InterruptedException;是阻塞的，如果队列内无空位，则一直等待，直到有空位才往队列中插入元素 &amp;ndash;&amp;gt;阻塞
poll() &amp;amp; take()
E poll(long timeout, TimeUnit unit) throws InterruptedException;取出队首元素，可取出就直接返回，否则等待，超时还未取出则失败
E take() throws InterruptedException;取出队首元素，阻塞等待直到可取出
JDK文档的注释中有相关使用范例代码，如下所示：
class BoundedBuffer { final Lock lock = new ReentrantLock(); final Condition notFull = lock.newCondition(); final Condition notEmpty = lock.newCondition(); final Object[] items = new Object[100]; int putptr, takeptr, count; public void put(Object x) throws InterruptedException { lock.</description>
    </item>
    
    <item>
      <title>实现生产者消费者(二)：Lock &amp; Condition</title>
      <link>https://xuepan-summer.github.io/summer-xuepan.github.io/posts/%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E4%BA%8C/</link>
      <pubDate>Wed, 11 Nov 2020 15:03:37 +0800</pubDate>
      
      <guid>https://xuepan-summer.github.io/summer-xuepan.github.io/posts/%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E4%BA%8C/</guid>
      <description>生产者-消费者模型介绍  生产者和消费者同一时间使用同一存储空间，生产者往空间里放东西，消费者从空间里拿东西
现在要实现的是：生产者生产十个随机数供消费者使用，消费者依次消耗十个随机数，相当于生产者生产一个随机数，就放在盘子里，然后消费者消费。生产者再生产，消费者再消费，直至十个随机数被消耗完，整个过程结束。
采用Lock &amp;amp; Condition方法  Lock是接口，里面有lock()方法和unlock()方法，除此之外，还有tryLock()方法、newCondition()方法等。相比于synchronized更加灵活，因为synchronized默认在出作用域的时候释放资源，相当于解锁。所以Lock可以更加灵活地控制何时上锁，何时解锁。
Condition也是接口，主要是await()方法和signal()/signalAll()方法。signal()方法会唤醒一个正在等待该Condition的线程，而signalAll()方法会唤醒所有正在等待该Condition的线程。
JDK文档的注释中有相关使用范例代码，如下所示：
class BoundedBuffer { final Lock lock = new ReentrantLock(); final Condition notFull = lock.newCondition(); final Condition notEmpty = lock.newCondition(); final Object[] items = new Object[100]; int putptr, takeptr, count; public void put(Object x) throws InterruptedException { lock.lock(); try { while (count == items.length) notFull.await(); items[putptr] = x; if (++putptr == items.length) putptr = 0; ++count; notEmpty.signal(); } finally { lock.</description>
    </item>
    
    <item>
      <title>实现生产者消费者(一)：wait() &amp; notify()</title>
      <link>https://xuepan-summer.github.io/summer-xuepan.github.io/posts/%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E4%B8%80/</link>
      <pubDate>Wed, 11 Nov 2020 14:41:23 +0800</pubDate>
      
      <guid>https://xuepan-summer.github.io/summer-xuepan.github.io/posts/%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E4%B8%80/</guid>
      <description>生产者-消费者模型介绍  生产者和消费者同一时间使用同一存储空间，生产者往空间里放东西，消费者从空间里拿东西
现在要实现的是：生产者生产十个随机数供消费者使用，消费者依次消耗十个随机数，相当于生产者生产一个随机数，就放在盘子里，然后消费者消费。生产者再生产，消费者再消费，直至十个随机数被消耗完，整个过程结束。
采用Object.wait() &amp;amp; notify()/notifyAll()方法  wait()表示让该线程等待
notify()/notifyAll()
Wakes up a single thread that is waiting on this object&#39;s monitor. If any threads are waiting on this object, one of them is chosen to be awakened. The choice is arbitrary and occurs at the discretion of the implementation. A thread waits on an object&#39;s monitor by calling one of the {@code wait} methods. notify()会随机唤醒一个等待该资源的线程
Wakes up all threads that are waiting on this object&#39;s monitor.</description>
    </item>
    
    <item>
      <title>Stream总结 &amp; Collections.sort()应用</title>
      <link>https://xuepan-summer.github.io/summer-xuepan.github.io/posts/stream%E6%80%BB%E7%BB%93%E5%8F%8Acollections.sort%E6%96%B9%E6%B3%95%E5%BA%94%E7%94%A8/</link>
      <pubDate>Mon, 02 Nov 2020 17:43:39 +0800</pubDate>
      
      <guid>https://xuepan-summer.github.io/summer-xuepan.github.io/posts/stream%E6%80%BB%E7%BB%93%E5%8F%8Acollections.sort%E6%96%B9%E6%B3%95%E5%BA%94%E7%94%A8/</guid>
      <description>学习了Stream之后，打算把Stream如何使用总结一下，便于下次翻阅。
一、Stream的创建操作、中间操作和终结操作 创建操作产生Stream
①某collection.stream()
②某stream.of()
③某string.chars()
④IntStream.range() 左闭右开
中间操作仍返回Stream
①filter() 过滤
②map() 映射
eg:map(User::getName)【方法引用】
③sorted()
eg:sorted(Comparator.comparing(某字段).thenComparing(某字段))
终结操作返回非Stream，包括void
①forEach()
②count()/max()/min()
③findFirst()/findAny
④anyMatch()/noneMatch()
collect()※ 是最常用的
Collectors.toList/toSet/toCollection
eg:Collectors.toCollection(TreeSet::new)
Collectors.groupingBy() 分组
eg:Collectors.groupingBy(Employee::getDepartment)
Collectors.joining() 连接
eg:Collectors.joining(&amp;quot;, &amp;ldquo;)
Collectors.summingInt() 累加求和
eg:Collectors.summingInt(Employee::getSalary)
二、Collections.sort()应用 1.包含两种传参方法
Collections.sort(list)
Collections.sort(list,Comparator)
2.java8新特性结合Collections.sort()
根据User的name对users(User类型的List)进行排序
有以下三种方法：
1.Comparator可以写成匿名内部类，实现compare方法
//1. Collections.sort(users, new Comparator&amp;lt;User&amp;gt;() { @Override public int compare(User user1, User user2) { return user1.getName().compareTo(user2.getName()); } }); 2.Comparator可以写成lambda表达式，如果写return的话需要加分号！
2.1是加上了参数类型的，参数表的参数类型可以忽略，如2.2所示
//2.1 复杂 Collections.sort(users, (User user1, User user2) -&amp;gt; { return user1.</description>
    </item>
    
    <item>
      <title>常用JVM分析工具</title>
      <link>https://xuepan-summer.github.io/summer-xuepan.github.io/posts/%E5%B8%B8%E7%94%A8jvm%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Sat, 10 Oct 2020 16:25:12 +0800</pubDate>
      
      <guid>https://xuepan-summer.github.io/summer-xuepan.github.io/posts/%E5%B8%B8%E7%94%A8jvm%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/</guid>
      <description>项目里出现了full GC问题之后，当时使用了Visual VM这种可视化工具发现了问题所在，但是日常开发也不能拘泥于这一种工具，还是应该多看看其他的工具，结合着使用，毕竟工具各有利弊。所以把这些工具和作用总结一下，便于使用时查阅。
常见jdk工具（命令行）  jps（JVM Process Status Tool）获取java进程的ID
  jstat（JVM Statistics Monitoring Tool）监视java进程的运行状态信息
  jinfo（Configuration Info for Java）获取java进程的配置信息，包括JVM的配置信息和系统属性
  jmap（Memory Map for Java）查看堆的使用情况且完成堆到文件的一个转储
  jhat（JVM Heap Dump Broswer）分析用jmap转储的二进制文件，通过浏览器可以查看jhat分析的结果
  jstack（Stack Trace for Java）查看应用程序的堆栈信息
  常见jdk工具（可视化）其实就是将上述的这个工具组合起来，以图形化页面展示出来
  JConsole
  Visual VM（1.5之后jdk已经自带了，可以直接使用，又名jVisual VM [java visual VM] ）
  使用工具是为了帮助我们发现问题，而在解决问题的时候，主要分析以下两点：内存分析和线程分析，分析具体又包括这四个方面&amp;ndash;监视、转储、快照和性能分析
监视：看CPU使用情况、内存使用情况、线程状态及其他信息，例如JConsole、Visual VM、JStack都可以
转储：从内存中获取当前状态数据并转储到文件，用于进行静态的性能分析
包括系统转储、Java转储、堆转储
  系统转储：又称核心转储，一般使用相关工具，例如Windows的windbg和Linux的gdb
  Java转储：JVM内部生成的格式化的数据，包括线程信息，类的加载信息，堆的统计数据等，通常用于检测死锁
  堆转储：所有对象的堆内容</description>
    </item>
    
    <item>
      <title>Linux常用命令总结</title>
      <link>https://xuepan-summer.github.io/summer-xuepan.github.io/posts/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</link>
      <pubDate>Wed, 30 Sep 2020 16:23:51 +0800</pubDate>
      
      <guid>https://xuepan-summer.github.io/summer-xuepan.github.io/posts/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</guid>
      <description>平时工作中有时候会用到一些常用的Linux命令，所以打算整理一下，便于翻阅，后续再补充
  目录切换命令
 pwd 查看当前路径    cd 目录名 切换到指定目录下
【cd命令系列】  cd ../ 切换到上级目录
  cd / 切换到根目录（所有用户共享的目录）
  cd ~ 切换到用户主目录，root用户相当于cd /root；普通用户相当于cd /home/当前用户名
  cd - 切换到上一个所在目录（此目录之前所在目录）
      目录或文件操作命令
  ls 显示不隐藏的文件或文件夹
  ls -a 显示当前目录下所有文件及文件夹，包括隐藏的.和..
  ls -l 显示不隐藏的文件与文件夹的详细信息 =&amp;gt;即 ll
  mkdir 目录名 创建目录
  touch 文件名 新建文件
【mv命令系列】  mv 旧文件 新文件 对文件重命名</description>
    </item>
    
    <item>
      <title>多线程</title>
      <link>https://xuepan-summer.github.io/summer-xuepan.github.io/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</link>
      <pubDate>Wed, 29 Jul 2020 14:45:08 +0800</pubDate>
      
      <guid>https://xuepan-summer.github.io/summer-xuepan.github.io/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</guid>
      <description>为什么需要多线程？    硬件需要：
CPU与其他设备的速度不同步，CPU很快，等执行完之后就进行等待，而且现在CPU大多是多核的，速度更快了。希望可以让CPU使用更加充分。
  程序需要：
java的执行模型是同步/阻塞的：默认是单线程，在执行的过程中，执行完第一行再执行第二行，一步一步来。假如第一行是执行一个很慢的方法，那么就会等这个方法执行结束再继续，这样就需要等待很久。
    多线程的过程
默认执行main线程，假如新开了线程a并start，那么就增加了一个执行流，main线程和线程a都有其私有的方法栈。
  start &amp;amp; run 的区别
  start相当于main线程（老板）给新线程（工人）分配完了之后就让工人自己去干活了，自己继续去做自己的事情。
  run相当于main线程（老板）给新线程（工人）分配了活并进行监工，等工人干完活之后再去做自己的事情。
如果让新线程执行run方法的话，和没有分多线程是一样的效果！！！只有start才可以并发执行！
    多线程会产生什么问题？
同一份代码，不同人乱序运行，如果不是原子操作（某一时刻只能被一个线程操作），那么就会时好时坏，有时就会出错
例子：i 初始值为0，线程a和线程b都执行同一方法中的i++操作
理想正确场景：线程a执行时 i 加1，变成1；线程b执行时 i 再加1，变成2（即使顺序调换，先线程b再线程a，结果也还是2）
实际报错场景：i++分为三步：
(1) 取出 i 的值
(2) i 的值加 1
(3) 将叠加之后的值给 i
假设线程a先占用了CPU，取出 i 的初始值0，然后 i 加1变成了1。但是！此时线程a占用CPU的时间到了，所以轮到了线程b，由于线程a还没将数据赋值给 i ，所以 i 的值还是0，线程2成功在其基础上加1并赋值给 i ，那么 i 就变成了1。接下来又轮到了线程a，线程a直接将刚刚叠加之后的结果1赋值给 i 。最终结果就变成了 1 而不是2。 如下图所示。</description>
    </item>
    
    <item>
      <title>深拷贝与浅拷贝</title>
      <link>https://xuepan-summer.github.io/summer-xuepan.github.io/posts/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/</link>
      <pubDate>Thu, 23 Jul 2020 14:47:32 +0800</pubDate>
      
      <guid>https://xuepan-summer.github.io/summer-xuepan.github.io/posts/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/</guid>
      <description>Home里定义了Cat
public class Home { public Cat cat; public Home(Cat cat) { this.cat = cat; } } Cat有其名字
public class Cat { public String name; public Cat(String name) { this.name = name; } } 在Main方法中定义一个Home类型的对象，对其进行拷贝
Home home = new Home(new Cat(&amp;#34;Tom&amp;#34;)); 相当于将名为Tom的猫放在Home里
在这个具体的例子中，
浅拷贝：将这只名为Tom的猫也放到新房子里
深拷贝：重新定义一只名为Tom的猫，将其放到新房子里
public static Home shallowCopy(Home home) { Home newHome = new Home(home.cat); return newHome; //此处只为方便理解，建议直接return new Home(home.cat); } home.cat就是刚开始home对象里的猫，然后通过构造器将其直接放到新建的newHome里面。
public static Home deepCopy(Home home) { Cat newCat = new Cat(home.</description>
    </item>
    
    <item>
      <title>Collection体系的常用类及其背后的数据结构</title>
      <link>https://xuepan-summer.github.io/summer-xuepan.github.io/posts/collection%E4%BD%93%E7%B3%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%8F%8A%E5%85%B6%E8%83%8C%E5%90%8E%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
      <pubDate>Sun, 28 Jun 2020 16:20:17 +0800</pubDate>
      
      <guid>https://xuepan-summer.github.io/summer-xuepan.github.io/posts/collection%E4%BD%93%E7%B3%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%8F%8A%E5%85%B6%E8%83%8C%E5%90%8E%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid>
      <description>集合有两个基本接口：Collection和Map
List是一个有序集合，Set里不包含重复元素，Queue是队列，遵循FIFO原则（First In First Out）
List
常用方法：
add()：增加元素
retainAll()：保留参数里的所有元素
containsAll()：是否包含参数这个集合里的所有元素
toArray()：转换成数组
1.ArrayList
2.LinkedList
3.Vector&amp;amp;Stack
现已不使用
ArrayList &amp;amp; LinkedList：1.实现方式：ArrayList 基于数组来实现，LinkedList基于双向链表来实现
2.内存占用：LinkedList比ArrayList 更占内存，因为还需要存储两个引用（指向前面的元素和后面的元素）
3.随机访问速度：ArrayList 更快
Set
1.EnumSet
该Set里的元素必须都是指定枚举类型的枚举值
2.HashSet
3.TreeSet
HashSet &amp;amp; TreeSetHashSet是二叉树实现的，加入的元素不一定和加入的顺序保持一致，这一点就和ArrayList不一样
TreeSet是SortedSet接口的唯一实现，元素是有序的，可以采用默认的排序方法，也可以自定义排序方法
Queue
1.Deque
双端队列，两端均可增加可减少元素
2.PriorityQueue
有优先级的队列，按关键字进行排序，插入元素的时候会自动找到合适位置插入
Map
1.HashMap
HashMap的实现没有被同步，所以它是线程不安全的，ConcurrentHashMap是线程安全的
HashMap在resize扩容的时候会造成死循环
2.TreeMap
TreeMap是基于红黑树实现的</description>
    </item>
    
    <item>
      <title>解决Maven包冲突问题</title>
      <link>https://xuepan-summer.github.io/summer-xuepan.github.io/posts/%E8%A7%A3%E5%86%B3maven%E5%8C%85%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98/</link>
      <pubDate>Fri, 26 Jun 2020 17:52:27 +0800</pubDate>
      
      <guid>https://xuepan-summer.github.io/summer-xuepan.github.io/posts/%E8%A7%A3%E5%86%B3maven%E5%8C%85%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98/</guid>
      <description>1.JVM（java虚拟机）的作用：
只执行class文件，也就是字节码文件，如果遇到了新类就会去相应类路径classPath里找。各个类的字节码文件一般都打包在jar包里。
2.传递性依赖：类依赖其他类
maven的包管理解决了传递性依赖和包冲突：
1）传递性依赖的解决：
maven会告诉jvm到底去哪找，根据groupId/artifactId/version去中央仓库可以找到自己想要的jar包，对应的jar包还有其pom文件，文件里会说明它又依赖了什么jar包，所以整棵依赖树都会被下载下来
2）包冲突的解决：
【1】包冲突是什么？版本号不同的包名同时出现在classPath里，则jvm不知道到底采用哪个包
【2】包冲突的表现：
AbstractMethodError
NoClassDefFoundError
ClassNotFoundException
LinkageError
NoSuchMethodError
【3】看包依赖的方法
法1：看右侧maven的dependencies
法2：命令行里执行mvn dependency:tree 看到的是maven解决冲突之后的结构
【4】 解决冲突的原则：
选择距离项目最近的jar包
当距离项目一样近时，选前者
【5】实例：
因为此时既依赖了0.1版本的C包，又依赖了0.2版本的C包，所以产生了包冲突
所以maven在解决包冲突的时候，选择了较近的0.1版本的C包，而舍弃了高版本
当高版本的jar包里有我们需要的方法时，此时就会报错，要想采用高版本的jar包，有以下几种方式：
① 直接依赖0.2版本的C包，修改pom.xml文件的dependencies
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.github.hcsp&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;test-library-c&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;0.2&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; ② 排除掉0.1版本的C包
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.github.hcsp&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;test-library-d&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;0.1&amp;lt;/version&amp;gt; &amp;lt;exclusions&amp;gt; &amp;lt;exclusion&amp;gt; &amp;lt;groupId&amp;gt;com.github.hcsp&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;test-library-c&amp;lt;/artifactId&amp;gt; &amp;lt;/exclusion&amp;gt; &amp;lt;/exclusions&amp;gt; &amp;lt;/dependency&amp;gt; ③ 采用IDEA的Maven Helper插件
打开pom，命令行上方有dependency Analyzer 点Reimport按钮，则显示了maven冲突的地方，选中要排除的那个,然后右键exclude</description>
    </item>
    
    <item>
      <title>类的访问控制符public、protected、default、private</title>
      <link>https://xuepan-summer.github.io/summer-xuepan.github.io/posts/%E7%B1%BB%E7%9A%84%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E7%AC%A6publicprotecteddefaultprivate/</link>
      <pubDate>Mon, 08 Jun 2020 09:31:16 +0800</pubDate>
      
      <guid>https://xuepan-summer.github.io/summer-xuepan.github.io/posts/%E7%B1%BB%E7%9A%84%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E7%AC%A6publicprotecteddefaultprivate/</guid>
      <description>private仅本类可用 package private包级私有（默认不写修饰符）仅本包及本类可用 protected 本类、本包、其子类均可用 public没有限制  具体如下图所示：</description>
    </item>
    
    <item>
      <title>Hugo搭建个人博客</title>
      <link>https://xuepan-summer.github.io/summer-xuepan.github.io/posts/hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</link>
      <pubDate>Sun, 07 Jun 2020 14:39:18 +0800</pubDate>
      
      <guid>https://xuepan-summer.github.io/summer-xuepan.github.io/posts/hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</guid>
      <description>1.安装hugo
Windows:
 下载windows相应版本的压缩包（对应32位/64位）并解压 将hugo.exe放到D:\softwares\hugo\hugo.exe 将D:\softwares\hugo加到PATH中 重启终端，运行hugo version查看版本验证安装成功  Mac:
  brew install hugo
  hugo version 验证安装成功
执行这两行代码即可
  2.参照文档搭建博客
  进入hugo官网 https://gohugo.io/ ，点击 Quick Start，则有搭建的全部步骤
在搭建之前，先打开一个目录，例如进入到D盘，然后cmder(即：在此处打开命令窗口)
  直接从官网步骤的第二步开始抄代码，一直到第七步
【2】create new site
hugo new site xxx.github.io-generator
xxx要小写，是自己的github用户名，则会在当前目录创建这个网站
  code xxx.github.io-generator/
则会在VSCode里打开该目录
  【3】add a theme 打开终端，继续照抄代码
  【4】add some content 创建文章，自己命名即可
  可以找到该md文件，直接写博客了，修改draft:true为draft:false
  【5】Start the Hugo server 可以看到网站地址了，ctrl+鼠标左键点进去就可以看到自己写的博客</description>
    </item>
    
    <item>
      <title>我的第一篇博客</title>
      <link>https://xuepan-summer.github.io/summer-xuepan.github.io/posts/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</link>
      <pubDate>Sun, 07 Jun 2020 11:56:45 +0800</pubDate>
      
      <guid>https://xuepan-summer.github.io/summer-xuepan.github.io/posts/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</guid>
      <description># 大家好
这是我的第一篇博客，希望可以将工作和学习中的内容多多总结，记录下来，也需要对别人有所帮助。</description>
    </item>
    
  </channel>
</rss>